import click
from collections import Counter, defaultdict
import logging
from pathlib import Path
import pysam
import json

# Pileup is 1-based positions, whereas BED is 0-based positions
PILEUP_TO_BED_OFFSET = 1


class NoBamIndex(Exception):
    pass


class PileupColumn:
    def __init__(
        self,
        chromosome: str,
        ref_pos: int,
        ref_base: str,
        depth: int,
        read_bases: str,
        base_qualities: str,
        mapping_qualities: str = "",
    ):
        self.chromosome = chromosome
        self.ref_pos = ref_pos
        self.ref_base = ref_base
        self.depth = depth
        self.read_bases = read_bases
        self.base_qualities = base_qualities
        self.mapping_qualities = mapping_qualities

    @staticmethod
    def from_string(line: str) -> "PileupColumn":
        fields = line.rstrip().split()
        mapping_qualities = "" if len(fields) < 7 else fields[6]
        return PileupColumn(
            chromosome=fields[0],
            ref_pos=int(fields[1]),
            ref_base=fields[2],
            depth=int(fields[3]),
            read_bases=fields[4],
            base_qualities=fields[5],
            mapping_qualities=mapping_qualities,
        )

    def matches(self) -> int:
        base_counts = Counter(self.read_bases)
        matches_forward = base_counts["."]
        matches_reverse = base_counts[","]
        return matches_forward + matches_reverse

    def match_ratio(self) -> float:
        try:
            return self.matches() / self.depth
        except ZeroDivisionError:
            return 0


def validate_file(ctx, param, value):
    if value.exists():
        return value
    else:
        raise click.BadParameter(f"{value} does not exist!")


def pileup_column_agrees_with_reference(column: PileupColumn, quorum: float) -> bool:
    """quorum says that this percent of bases in the column must agree
    with the reference base for it to be considered consensus."""
    match_percent = column.match_ratio() * 100
    logging.debug(
        f"Position {column.ref_pos} on {column.chromosome} has {column.matches()} "
        f"matches out of {column.depth} reads covering the site ("
        f"{round(match_percent, 2)}% match)."
    )
    return match_percent >= quorum


@click.command()
@click.help_option("--help", "-h")
@click.option(
    "--bam",
    help=(
        "Bam file to assess. It is up to the user whether to include "
        "secondary/supplementary alignments. These can be removed with "
        "`samtools view -bh -f 0 -F 256"
    ),
    type=Path,
    required=True,
    callback=validate_file,
)
@click.option(
    "--pileup",
    help=(
        "Pileup file generated by samtools mpileup. It is recommended that the pileup "
        "is generated using the mpileup flag -aa to report absolutely all positions."
    ),
    type=Path,
    required=True,
    callback=validate_file,
)
@click.option(
    "-p",
    "--prefix",
    help="Path prefix to write output json and BED file to.",
    type=str,
    required=True,
)
@click.option(
    "--quorum",
    help="Percentage of bases that must agree with reference at each position.",
    type=float,
    default=95.0,
    show_default=True,
)
@click.option(
    "-v",
    "--verbose",
    help="Turns on debug-level logging.",
    is_flag=True,
    flag_value=True,
)
def main(bam: Path, pileup: Path, quorum: float, prefix: str, verbose: bool):
    """A script to assess the per-base quality of an assembly. There are two key
    metrics analysed here:
    1. Per-base consensus of reads mapped to the assembly. Consensus is defined as
    whether the the percentage of reads matching the assembly position at a site is
    greater than or equal to the value passed to --quorum
    2. Mapping quality summary statistics. i.e. mean, median, quantiles etc.
    """
    log_level = logging.DEBUG if verbose else logging.INFO
    logging.basicConfig(format="%(levelname)s: %(message)s", level=log_level)

    summary_stats = dict()

    logging.info("Assessing pileup...")
    disagreement_positions = defaultdict(list)
    num_disagreements = 0
    with pileup.open() as pileup_handle:
        for position_counter, line in enumerate(pileup_handle, start=1):
            column = PileupColumn.from_string(line)
            if not pileup_column_agrees_with_reference(column, quorum):
                num_disagreements += 1
                disagreement_positions[column.chromosome].append(
                    column.ref_pos - PILEUP_TO_BED_OFFSET
                )

    logging.info(f"There are {num_disagreements} disagreements in total.")
    summary_stats["total_disagreements"] = num_disagreements
    logging.info(f"There are {position_counter} total positions in the pileup.")
    summary_stats["total_pileup_positions"] = position_counter
    percent_disagree = num_disagreements / position_counter * 100
    logging.info(
        f"Therefore, {round(percent_disagree, 2)}% of positions did not reach quorum."
    )
    summary_stats["percent_pileup_disagree"] = percent_disagree

    logging.info("Assessing mapping quality...")
    with pysam.AlignmentFile(bam) as alignment:
        alignment.check_index()

        for record in alignment:
            mean_mapq = sum(mapping_qualities) / column.n
            mean_position_mapping_qual.append(mean_mapq)
            positions_covered_by_pileup += 1

        for record in alignment:
            all_mapping_qualities.append(record.mapping_quality)

    base_disagreements += num_bases - positions_covered_by_pileup

    logging.info(
        f"There are {base_disagreements} positions that disagree with the assembly."
    )

    perc_disagree = base_disagreements / num_bases * 100

    logging.info(
        f"{perc_disagree}% of the assembly positions disagree with the reads in the BAM."
    )

    mean_per_base_mapping_quality = sum(mean_position_mapping_qual) / num_bases
    logging.info(f"Mean per-base mapping quality is {mean_per_base_mapping_quality}")
    mean_total_mapping_quality = sum(all_mapping_qualities) / len(all_mapping_qualities)
    logging.info(f"Overall mean mapping quality is {mean_total_mapping_quality}")

    with outfile.open("w") as handle:
        print(
            json.dumps(
                {
                    "base_disagreements": base_disagreements,
                    "total_bases": num_bases,
                    "percent_bases_disagree": perc_disagree,
                    "mean_per_base_mapping_quality": mean_per_base_mapping_quality,
                    "mean_per_read_mapping_quality": mean_total_mapping_quality,
                },
                sort_keys=True,
                indent=4,
            ),
            file=handle,
        )


if __name__ == "__main__":
    main()
